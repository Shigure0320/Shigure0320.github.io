<!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><title>Leetcode笔记-贪心算法 | 时雨的安全屋</title><script src="https://cdn.bootcss.com/valine/1.4.4/Valine.min.js"></script><link rel="stylesheet" href="/css/arknights.css"><link rel="stylesheet" href="https://cdn.bootcdn.net/ajax/libs/highlight.js/10.1.2/styles/atom-one-dark-reasonable.min.css"><style>@font-face {
 font-family: BenderLight;
 src: local('Bender'), url("/font/BenderLight.ttf");
}
@font-face {
 font-family: 'JetBrains Mono';
 src: local('JetBrains Mono'), url('/font/JetBrainsMono-Regular.woff2') format('woff2');
}</style><meta name="generator" content="Hexo 5.3.0"></head><body><header><nav><a href="/">Home</a><a href="/archives/">Archives</a></nav></header><main><article><div id="post-bg"><div id="post-title"><div id="post-info"><span>date:<time datetime="2021-03-27T08:56:03.000Z" id="date"> 2021-03-27</time></span><br><span>updated:<time datetime="2021-03-27T08:56:24.149Z" id="updated"> 2021-03-27</time></span></div><h1>Leetcode笔记-贪心算法</h1><hr></div><div id="post-content"><p>所谓贪心算法，就是采用贪心的策略，保证每次操作都是局部最优的，从而使最后得到的结果是全局最优的。也就是每一步都取最好的值，以此来达到总体的最好值。<br>考研的时候为了应付上机考试对贪心算法有了一个粗略的了解，但是并没有进行深入的研究，现在尝试去进一步了解贪心这个算法大类，具体什么问题下适用，如何巧妙的利用都是值得关注的点。</p>
<h3 id="分配问题"><a href="#分配问题" class="headerlink" title="分配问题"></a>分配问题</h3><h4 id="455-分配饼干"><a href="#455-分配饼干" class="headerlink" title="455.分配饼干"></a>455.分配饼干</h4><blockquote>
<p>有一群孩子和一堆饼干，每个孩子有一个饥饿度，每个饼干都有一个大小。每个孩子只能吃最多一个饼干，且只有饼干的大小大于孩子的饥饿度时，这个孩子才能吃饱。求解最多有多少孩子可以吃饱。</p>
</blockquote>
<p>由题意，最小饥饿度的小孩可以用尽量小的饼干满足来增加吃饱孩子的个数，当我们用大小大于这个孩子饥饿度的且最小的饼干给这个孩子，满足了这个孩子之后，用同样的策略去满足剩下的孩子，就可以得到算法的全局最优，所以贪心的策略是尽量用小块的饼干去满足不那么饿的孩子，为了方便查找，可以先进行排序。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int findContentChildren(vector&lt;int&gt;&amp; g, vector&lt;int&gt;&amp; s) &#123;</span><br><span class="line">        sort(g.begin(),g.end());&#x2F;&#x2F;对胃口大小排序</span><br><span class="line">        sort(s.begin(),s.end());&#x2F;&#x2F;对饼干大小排序</span><br><span class="line">        int child&#x3D;0;</span><br><span class="line">        int cookie&#x3D;0;</span><br><span class="line">        while(child&lt;g.size() &amp;&amp; cookie&lt;s.size())&#123;</span><br><span class="line">            if(s[cookie]&gt;&#x3D;g[child])&#123;&#x2F;&#x2F;如果当前饼干可以满足该小孩，去看下一个</span><br><span class="line">                cookie++;</span><br><span class="line">                child++;</span><br><span class="line">            &#125;</span><br><span class="line">            else</span><br><span class="line">                cookie++;&#x2F;&#x2F;如果不能则看下一块饼干能否满足这个小孩</span><br><span class="line">        &#125;</span><br><span class="line">        return child;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="135-分发糖果"><a href="#135-分发糖果" class="headerlink" title="135.分发糖果"></a>135.分发糖果</h4><blockquote>
<p>一群孩子站成一排，每一个孩子有自己的评分。现在需要给这些孩子发糖果，规则是如果一个孩子的评分比自己身旁的一个孩子要高，那么这个孩子就必须得到比身旁孩子更多的糖果；所有孩子至少要有一个糖果。求解最少需要多少个糖果。</p>
</blockquote>
<p>有一个巧妙的2次遍历来解这道题，把所有孩子的糖果数初始化为 1；<br>先从左往右遍历一遍，如果右边孩子的评分比左边的高，则右边孩子的糖果数更新为左边孩子的糖果数加 1；再从右往左遍历一遍，如果左边孩子的评分比右边的高，且左边孩子当前的糖果数不大于右边孩子的糖果数，则左边孩子的糖果数更新为右边孩子的糖果数加 1。通过这两次遍历，分配的糖果就可以满足题目要求了。这里的贪心策略即为，在每次遍历中，只考虑并更新相邻一侧的大小关系。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int candy(vector&lt;int&gt;&amp; ratings) &#123;</span><br><span class="line">        int size&#x3D;ratings.size();</span><br><span class="line">        vector&lt;int&gt; cand(size,1);</span><br><span class="line">        for(int i&#x3D;0;i&lt;size-1;i++)&#123;</span><br><span class="line">            if(ratings[i]&lt;ratings[i+1])</span><br><span class="line">                cand[i+1]&#x3D;cand[i]+1;</span><br><span class="line">        &#125;</span><br><span class="line">        for(int i&#x3D;size-1;i&gt;0;i--)&#123;</span><br><span class="line">            if(ratings[i]&lt;ratings[i-1])&#123;</span><br><span class="line">                cand[i-1]&#x3D;max(cand[i-1],cand[i]+1);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return accumulate(cand.begin(),cand.end(),0);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="区间问题"><a href="#区间问题" class="headerlink" title="区间问题"></a>区间问题</h3><h4 id="435-不重叠的区间"><a href="#435-不重叠的区间" class="headerlink" title="435.不重叠的区间"></a>435.不重叠的区间</h4><blockquote>
<p>给定多个区间，计算让这些区间互不重叠所需要移除区间的最少个数。起止相连不算重叠。</p>
</blockquote>
<p>在选择要保留区间时，区间的结尾十分重要：选择的区间结尾越小，余留给其它区间的空间就越大，就越能保留更多的区间。因此，我们采取的贪心策略为，优先保留结尾小且不相交的区间。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int eraseOverlapIntervals(vector&lt;vector&lt;int&gt;&gt;&amp; intervals) &#123;</span><br><span class="line">        int n&#x3D;intervals.size();</span><br><span class="line">        if(n&#x3D;&#x3D;0) return 0;</span><br><span class="line">        sort(intervals.begin(),intervals.end(),[](vector&lt;int&gt; a,vector&lt;int&gt; b)&#123;return a[1]&lt;b[1];&#125;);</span><br><span class="line">        int count&#x3D;0;</span><br><span class="line">        int prev&#x3D;intervals[0][1];</span><br><span class="line">        for(int i&#x3D;1;i&lt;n;i++)&#123;</span><br><span class="line">            if(intervals[i][0]&lt;prev)</span><br><span class="line">                count++;</span><br><span class="line">            else</span><br><span class="line">                prev&#x3D;intervals[i][1];</span><br><span class="line">        &#125;</span><br><span class="line">        return count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>嗯，回味一下贪心算法能适用的前提，就是局部的最优解能导致产生全局的最优解嘛，很多题如果看不出来能不能用或者不知道怎么写，先试着写一下贪心，不行再尝试动态规划或者其他方法也是可以的。</p>
<div id="paginator"></div></div><div id="post-footer"><hr><a href="/2021/03/27/Leetcode%E7%AC%94%E8%AE%B0-%E5%8F%8C%E6%8C%87%E9%92%88%EF%BC%8C%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3/">Leetcode笔记-双指针，滑动窗口 Next →</a><hr></div><div id="bottom-btn"><a id="to-index" href="#post-index" title="index">≡</a><a id="to-top" href="#post-title" title="to top">∧</a></div><details id="reward"><summary>打赏</summary><div id="alipay"><span>支付宝 | Alipay</span><br><img src="/img/Alipay.png"></div><div id="wechat"><span>微信 | WeChat</span><br><img src="/img/WeChat.png"></div></details><div id="Valine"></div><script>new Valine({
 el: '#Valine'
 , appId: ''
 , appKey: ''
 , placeholder: '此条评论委托企鹅物流发送'
})</script></div></article><aside><div id="about"><a href="/" id="logo"><img src="https://ak.hypergryph.com/assets/index/images/ak/pc/faction/1.png" alt="Logo"></a><h1 id="Dr"><a href="/"> Dr.时雨</a></h1><section id="total"><a id="total-archives" href="/archives"><span class="total-title">Archives Total:</span><span class="total-number">4</span></a><div id="total-tags"><span class="total-title">Tags:</span><span class="total-number">0</span></div><div id="total-categories"><span class="total-title">Categories:</span><span class="total-number">0</span></div></section></div><div id="aside-block"><h1>INDEX</h1><div id="post-index"><ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%86%E9%85%8D%E9%97%AE%E9%A2%98"><span class="toc-number">1.</span> <span class="toc-text">分配问题</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#455-%E5%88%86%E9%85%8D%E9%A5%BC%E5%B9%B2"><span class="toc-number">1.1.</span> <span class="toc-text">455.分配饼干</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#135-%E5%88%86%E5%8F%91%E7%B3%96%E6%9E%9C"><span class="toc-number">1.2.</span> <span class="toc-text">135.分发糖果</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8C%BA%E9%97%B4%E9%97%AE%E9%A2%98"><span class="toc-number">2.</span> <span class="toc-text">区间问题</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#435-%E4%B8%8D%E9%87%8D%E5%8F%A0%E7%9A%84%E5%8C%BA%E9%97%B4"><span class="toc-number">2.1.</span> <span class="toc-text">435.不重叠的区间</span></a></li></ol></li></ol></div></div><footer><nobr><span class="text-title">©</span><span class="text-content">2021 to ???</span></nobr><wbr><nobr><span class="text-title">ICP</span><span class="text-content">——???——</span></nobr><wbr><wbr><nobr>Theme&nbsp;<a target="_blank" rel="noopener" href="https://github.com/Yue-plus/hexo-theme-arknights">Arknight&nbsp;</a></nobr><wbr><nobr>by&nbsp;<a target="_blank" rel="noopener" href="https://github.com/Yue-plus">Yue_plus</a></nobr></footer></aside></main><canvas id="canvas-dust"></canvas><script src="/js/arknights.js"></script><script src="https://cdn.bootcdn.net/ajax/libs/highlight.js/10.1.2/highlight.min.js"></script></body></html>